"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginContext = exports.SimpleEvidenceCollection = void 0;
exports.getPluginContext = getPluginContext;
exports.setPluginContext = setPluginContext;
exports.initJiraOptions = initJiraOptions;
exports.initPluginOptions = initPluginOptions;
exports.initXrayOptions = initXrayOptions;
exports.initCucumberOptions = initCucumberOptions;
exports.initHttpClients = initHttpClients;
exports.initClients = initClients;
const credentials_1 = require("./client/authentication/credentials");
const requests_1 = require("./client/https/requests");
const jira_client_1 = require("./client/jira/jira-client");
const xray_client_cloud_1 = require("./client/xray/xray-client-cloud");
const xray_client_server_1 = require("./client/xray/xray-client-server");
const env_1 = require("./env");
const dedent_1 = require("./util/dedent");
const dependencies_1 = require("./util/dependencies");
const errors_1 = require("./util/errors");
const help_1 = require("./util/help");
const logging_1 = require("./util/logging");
const parsing_1 = require("./util/parsing");
class SimpleEvidenceCollection {
    collectedEvidence = new Map();
    addEvidence(issueKey, evidence) {
        const currentEvidence = this.collectedEvidence.get(issueKey);
        if (!currentEvidence) {
            this.collectedEvidence.set(issueKey, [evidence]);
        }
        else {
            currentEvidence.push(evidence);
        }
    }
    getEvidence(issueKey) {
        return this.collectedEvidence.get(issueKey) ?? [];
    }
}
exports.SimpleEvidenceCollection = SimpleEvidenceCollection;
class PluginContext {
    clients;
    internalOptions;
    cypressOptions;
    evidenceCollection;
    graph;
    logger;
    constructor(clients, internalOptions, cypressOptions, evidenceCollection, graph, logger) {
        this.clients = clients;
        this.internalOptions = internalOptions;
        this.cypressOptions = cypressOptions;
        this.evidenceCollection = evidenceCollection;
        this.graph = graph;
        this.logger = logger;
    }
    getClients() {
        return this.clients;
    }
    getOptions() {
        return this.internalOptions;
    }
    getCypressOptions() {
        return this.cypressOptions;
    }
    getGraph() {
        return this.graph;
    }
    getLogger() {
        return this.logger;
    }
    addEvidence(issueKey, evidence) {
        this.evidenceCollection.addEvidence(issueKey, evidence);
        logging_1.LOG.message(logging_1.Level.DEBUG, `Added evidence for test ${issueKey}: ${evidence.filename}`);
    }
    getEvidence(issueKey) {
        return this.evidenceCollection.getEvidence(issueKey);
    }
}
exports.PluginContext = PluginContext;
let context = undefined;
function getPluginContext() {
    return context;
}
function setPluginContext(newContext) {
    context = newContext;
}
/**
 * Returns an {@link InternalJiraOptions | `InternalJiraOptions`} instance based on parsed
 * environment variables and a provided options object. Environment variables will take precedence
 * over the options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing Jira options
 * @returns the constructed internal Jira options
 */
function initJiraOptions(env, options) {
    const projectKey = (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.projectKey, parsing_1.asString) ?? options.projectKey;
    if (!projectKey) {
        throw new Error("Plugin misconfiguration: Jira project key was not set");
    }
    const testExecutionIssueKey = (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssueKey, parsing_1.asString) ?? options.testExecutionIssueKey;
    if (testExecutionIssueKey && !testExecutionIssueKey.startsWith(projectKey)) {
        throw new Error(`Plugin misconfiguration: test execution issue key ${testExecutionIssueKey} does not belong to project ${projectKey}`);
    }
    const testPlanIssueKey = (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testPlanIssueKey, parsing_1.asString) ?? options.testPlanIssueKey;
    if (testPlanIssueKey && !testPlanIssueKey.startsWith(projectKey)) {
        throw new Error(`Plugin misconfiguration: test plan issue key ${testPlanIssueKey} does not belong to project ${projectKey}`);
    }
    return {
        attachVideos: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.attachVideos, parsing_1.asBoolean) ?? options.attachVideos ?? false,
        fields: {
            description: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.description, parsing_1.asString) ??
                options.fields?.description,
            labels: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.labels, parsing_1.asString) ?? options.fields?.labels,
            summary: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.summary, parsing_1.asString) ?? options.fields?.summary,
            testEnvironments: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.testEnvironments, parsing_1.asString) ??
                options.fields?.testEnvironments,
            testPlan: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.testPlan, parsing_1.asString) ?? options.fields?.testPlan,
            testType: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.fields.testType, parsing_1.asString) ?? options.fields?.testType,
        },
        projectKey: projectKey,
        testExecutionIssue: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssue, parsing_1.asObject) ?? options.testExecutionIssue,
        testExecutionIssueDescription: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssueDescription, parsing_1.asString) ??
            options.testExecutionIssueDescription,
        testExecutionIssueKey: testExecutionIssueKey,
        testExecutionIssueSummary: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssueSummary, parsing_1.asString) ??
            options.testExecutionIssueSummary,
        testExecutionIssueType: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testExecutionIssueType, parsing_1.asString) ??
            options.testExecutionIssueType ??
            "Test Execution",
        testPlanIssueKey: testPlanIssueKey,
        testPlanIssueType: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.testPlanIssueType, parsing_1.asString) ??
            options.testPlanIssueType ??
            "Test Plan",
        url: (0, parsing_1.parse)(env, env_1.ENV_NAMES.jira.url, parsing_1.asString) ?? options.url,
    };
}
/**
 * Returns an {@link InternalPluginOptions | `InternalPluginOptions`} instance based on parsed
 * environment variables and a provided options object. Environment variables will take precedence
 * over the options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing plugin options
 * @returns the constructed internal plugin options
 */
function initPluginOptions(env, options) {
    return {
        debug: (0, parsing_1.parse)(env, env_1.ENV_NAMES.plugin.debug, parsing_1.asBoolean) ?? options?.debug ?? false,
        enabled: (0, parsing_1.parse)(env, env_1.ENV_NAMES.plugin.enabled, parsing_1.asBoolean) ?? options?.enabled ?? true,
        logDirectory: (0, parsing_1.parse)(env, env_1.ENV_NAMES.plugin.logDirectory, parsing_1.asString) ?? options?.logDirectory ?? "logs",
        normalizeScreenshotNames: (0, parsing_1.parse)(env, env_1.ENV_NAMES.plugin.normalizeScreenshotNames, parsing_1.asBoolean) ??
            options?.normalizeScreenshotNames ??
            false,
    };
}
/**
 * Returns an {@link InternalXrayOptions | `InternalXrayOptions`} instance based on parsed environment
 * variables and a provided options object. Environment variables will take precedence over the
 * options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing Xray options
 * @returns the constructed internal Xray options
 */
function initXrayOptions(env, options) {
    return {
        status: {
            failed: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.failed, parsing_1.asString) ?? options?.status?.failed,
            passed: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.passed, parsing_1.asString) ?? options?.status?.passed,
            pending: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.pending, parsing_1.asString) ?? options?.status?.pending,
            skipped: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.skipped, parsing_1.asString) ?? options?.status?.skipped,
            step: {
                failed: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.step.failed, parsing_1.asString) ??
                    options?.status?.step?.failed,
                passed: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.step.passed, parsing_1.asString) ??
                    options?.status?.step?.passed,
                pending: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.step.pending, parsing_1.asString) ??
                    options?.status?.step?.pending,
                skipped: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.status.step.skipped, parsing_1.asString) ??
                    options?.status?.step?.skipped,
            },
        },
        testEnvironments: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.testEnvironments, parsing_1.asArrayOfStrings) ??
            options?.testEnvironments,
        uploadRequests: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.uploadRequests, parsing_1.asBoolean) ??
            options?.uploadRequests ??
            false,
        uploadResults: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.uploadResults, parsing_1.asBoolean) ?? options?.uploadResults ?? true,
        uploadScreenshots: (0, parsing_1.parse)(env, env_1.ENV_NAMES.xray.uploadScreenshots, parsing_1.asBoolean) ??
            options?.uploadScreenshots ??
            true,
    };
}
/**
 * Returns an {@link InternalCucumberOptions | `InternalCucumberOptions`} instance based on parsed
 * environment variables and a provided options object. Environment variables will take precedence
 * over the options set in the object.
 *
 * @param env - an object containing environment variables as properties
 * @param options - an options object containing Cucumber options
 * @returns the constructed internal Cucumber options
 */
async function initCucumberOptions(config, options) {
    // Check if the user has chosen to upload Cucumber results, too.
    const featureFileExtension = (0, parsing_1.parse)(config.env, env_1.ENV_NAMES.cucumber.featureFileExtension, parsing_1.asString) ??
        options?.featureFileExtension;
    // If the user has chosen to do so, we need to make sure they configured the Cucumber
    // preprocessor JSON report as well. Otherwise, results upload will not work.
    if (featureFileExtension) {
        let preprocessor;
        try {
            preprocessor = await (0, dependencies_1.importOptionalDependency)("@badeball/cypress-cucumber-preprocessor");
        }
        catch (error) {
            throw new Error((0, dedent_1.dedent)(`
                    Plugin dependency misconfigured: @badeball/cypress-cucumber-preprocessor

                    ${(0, errors_1.errorMessage)(error)}

                    The plugin depends on the package and should automatically download it during installation, but might have failed to do so because of conflicting Node versions

                    Make sure to install the package manually using: npm install @badeball/cypress-cucumber-preprocessor --save-dev
                `));
        }
        logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully resolved configuration of @badeball/cypress-cucumber-preprocessor package`);
        const preprocessorConfiguration = await preprocessor.resolvePreprocessorConfiguration(config, config.env, "/");
        if (!preprocessorConfiguration.json.enabled) {
            throw new Error((0, dedent_1.dedent)(`
                        Plugin misconfiguration: Cucumber preprocessor JSON report disabled

                        Make sure to enable the JSON report as described in https://github.com/badeball/cypress-cucumber-preprocessor/blob/master/docs/json-report.md
                    `));
        }
        if (!preprocessorConfiguration.json.output) {
            throw new Error((0, dedent_1.dedent)(`
                        Plugin misconfiguration: Cucumber preprocessor JSON report path was not set

                        Make sure to configure the JSON report path as described in https://github.com/badeball/cypress-cucumber-preprocessor/blob/master/docs/json-report.md
                    `));
        }
        return {
            downloadFeatures: (0, parsing_1.parse)(config.env, env_1.ENV_NAMES.cucumber.downloadFeatures, parsing_1.asBoolean) ??
                options?.downloadFeatures ??
                false,
            featureFileExtension: featureFileExtension,
            prefixes: {
                precondition: (0, parsing_1.parse)(config.env, env_1.ENV_NAMES.cucumber.prefixes.precondition, parsing_1.asString) ??
                    options?.prefixes?.precondition,
                test: (0, parsing_1.parse)(config.env, env_1.ENV_NAMES.cucumber.prefixes.test, parsing_1.asString) ??
                    options?.prefixes?.test,
            },
            preprocessor: preprocessorConfiguration,
            uploadFeatures: (0, parsing_1.parse)(config.env, env_1.ENV_NAMES.cucumber.uploadFeatures, parsing_1.asBoolean) ??
                options?.uploadFeatures ??
                false,
        };
    }
    return undefined;
}
function initHttpClients(pluginOptions, httpOptions) {
    let jiraClient = undefined;
    let xrayClient = undefined;
    if (httpOptions) {
        const { jira, rateLimiting: rateLimitingCommon, xray, ...httpConfigCommon } = httpOptions;
        if (jira) {
            const { rateLimiting, ...httpConfig } = jira;
            jiraClient = new requests_1.AxiosRestClient({
                debug: pluginOptions?.debug,
                http: {
                    ...httpConfigCommon,
                    ...httpConfig,
                },
                rateLimiting: rateLimiting ?? rateLimitingCommon,
            });
        }
        if (xray) {
            const { rateLimiting, ...httpConfig } = xray;
            xrayClient = new requests_1.AxiosRestClient({
                debug: pluginOptions?.debug,
                http: {
                    ...httpConfigCommon,
                    ...httpConfig,
                },
                rateLimiting: rateLimiting ?? rateLimitingCommon,
            });
        }
        if (!jiraClient || !xrayClient) {
            const httpClient = new requests_1.AxiosRestClient({
                debug: pluginOptions?.debug,
                http: httpConfigCommon,
                rateLimiting: rateLimitingCommon,
            });
            if (!jiraClient) {
                jiraClient = httpClient;
            }
            if (!xrayClient) {
                xrayClient = httpClient;
            }
        }
    }
    else {
        const httpClient = new requests_1.AxiosRestClient({
            debug: pluginOptions?.debug,
        });
        jiraClient = httpClient;
        xrayClient = httpClient;
    }
    return {
        jira: jiraClient,
        xray: xrayClient,
    };
}
async function initClients(jiraOptions, env, httpClients) {
    if (env_1.ENV_NAMES.authentication.jira.username in env &&
        env_1.ENV_NAMES.authentication.jira.apiToken in env) {
        logging_1.LOG.message(logging_1.Level.INFO, "Jira username and API token found. Setting up Jira cloud basic auth credentials.");
        const credentials = new credentials_1.BasicAuthCredentials(env[env_1.ENV_NAMES.authentication.jira.username], env[env_1.ENV_NAMES.authentication.jira.apiToken]);
        const jiraClient = await getJiraClient(jiraOptions.url, credentials, httpClients.jira);
        if (env_1.ENV_NAMES.authentication.xray.clientId in env &&
            env_1.ENV_NAMES.authentication.xray.clientSecret in env) {
            logging_1.LOG.message(logging_1.Level.INFO, "Xray client ID and client secret found. Setting up Xray cloud JWT credentials.");
            const xrayCredentials = new credentials_1.JwtCredentials(env[env_1.ENV_NAMES.authentication.xray.clientId], env[env_1.ENV_NAMES.authentication.xray.clientSecret], `${xray_client_cloud_1.XrayClientCloud.URL}/authenticate`, httpClients.xray);
            const xrayClient = await getXrayCloudClient(xrayCredentials, httpClients.xray);
            return {
                jiraClient: jiraClient,
                kind: "cloud",
                xrayClient: xrayClient,
            };
        }
        throw new Error((0, dedent_1.dedent)(`
                Failed to configure Xray client: Jira cloud credentials detected, but the provided Xray credentials are not Xray cloud credentials.

                  You can find all configurations currently supported at: ${help_1.HELP.plugin.configuration.authentication.root}
            `));
    }
    else if (env_1.ENV_NAMES.authentication.jira.apiToken in env) {
        logging_1.LOG.message(logging_1.Level.INFO, "Jira PAT found. Setting up Jira server PAT credentials.");
        const credentials = new credentials_1.PatCredentials(env[env_1.ENV_NAMES.authentication.jira.apiToken]);
        const jiraClient = await getJiraClient(jiraOptions.url, credentials, httpClients.jira);
        logging_1.LOG.message(logging_1.Level.INFO, "Jira PAT found. Setting up Xray server PAT credentials.");
        const xrayClient = await getXrayServerClient(jiraOptions.url, credentials, httpClients.xray);
        return {
            jiraClient: jiraClient,
            kind: "server",
            xrayClient: xrayClient,
        };
    }
    else if (env_1.ENV_NAMES.authentication.jira.username in env &&
        env_1.ENV_NAMES.authentication.jira.password in env) {
        logging_1.LOG.message(logging_1.Level.INFO, "Jira username and password found. Setting up Jira server basic auth credentials.");
        const credentials = new credentials_1.BasicAuthCredentials(env[env_1.ENV_NAMES.authentication.jira.username], env[env_1.ENV_NAMES.authentication.jira.password]);
        const jiraClient = await getJiraClient(jiraOptions.url, credentials, httpClients.jira);
        logging_1.LOG.message(logging_1.Level.INFO, "Jira username and password found. Setting up Xray server basic auth credentials.");
        const xrayClient = await getXrayServerClient(jiraOptions.url, credentials, httpClients.xray);
        return {
            jiraClient: jiraClient,
            kind: "server",
            xrayClient: xrayClient,
        };
    }
    throw new Error((0, dedent_1.dedent)(`
            Failed to configure Jira client: No viable authentication method was configured.

              You can find all configurations currently supported at: ${help_1.HELP.plugin.configuration.authentication.root}
        `));
}
async function getXrayCloudClient(credentials, httpClient) {
    const xrayClient = new xray_client_cloud_1.XrayClientCloud(credentials, httpClient);
    try {
        await credentials.getAuthorizationHeader();
        logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                Successfully established communication with: ${credentials.getAuthenticationUrl()}

                  The provided credentials belong to a user with a valid Xray license.
            `));
    }
    catch (error) {
        throw new Error((0, dedent_1.dedent)(`
                Failed to establish communication with Xray: ${credentials.getAuthenticationUrl()}

                  ${(0, errors_1.errorMessage)(error)}

                Make sure you have correctly set up:
                - Xray cloud authentication: ${help_1.HELP.plugin.configuration.authentication.xray.cloud}
                - Xray itself: ${help_1.HELP.xray.installation.cloud}

                For more information, set the plugin to debug mode: ${help_1.HELP.plugin.configuration.plugin.debug}
            `));
    }
    return xrayClient;
}
async function getXrayServerClient(url, credentials, httpClient) {
    const xrayClient = new xray_client_server_1.ServerClient(url, credentials, httpClient);
    try {
        const license = await xrayClient.getXrayLicense();
        if (typeof license === "object" && "active" in license) {
            if (license.active) {
                logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                        Successfully established communication with: ${url}

                          Xray license is active: ${license.licenseType}
                    `));
                return xrayClient;
            }
            else {
                throw new Error("The Xray license is not active");
            }
        }
        throw new Error((0, dedent_1.dedent)(`
                Xray did not return a valid response: JSON containing basic Xray license information was expected, but not received.
            `));
    }
    catch (error) {
        throw new Error((0, dedent_1.dedent)(`
                Failed to establish communication with Xray: ${url}

                  ${(0, errors_1.errorMessage)(error)}

                Make sure you have correctly set up:
                - Jira base URL: ${help_1.HELP.plugin.configuration.jira.url}
                - Xray server authentication: ${help_1.HELP.plugin.configuration.authentication.xray.server}
                - Xray itself: ${help_1.HELP.xray.installation.server}

                For more information, set the plugin to debug mode: ${help_1.HELP.plugin.configuration.plugin.debug}
            `));
    }
}
async function getJiraClient(url, credentials, httpClient) {
    const jiraClient = new jira_client_1.BaseJiraClient(url, credentials, httpClient);
    try {
        const userDetails = await jiraClient.getMyself();
        const username = userDetails.displayName ?? userDetails.emailAddress ?? userDetails.name;
        if (username) {
            logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                    Successfully established communication with: ${url}

                      The provided Jira credentials belong to: ${username}
               `));
            return jiraClient;
        }
        else {
            throw new Error((0, dedent_1.dedent)(`
                Jira did not return a valid response: JSON containing a username was expected, but not received.
            `));
        }
    }
    catch (error) {
        throw new Error((0, dedent_1.dedent)(`
                Failed to establish communication with Jira: ${url}

                  ${(0, errors_1.errorMessage)(error)}

                Make sure you have correctly set up:
                - Jira base URL: ${help_1.HELP.plugin.configuration.jira.url}
                - Jira authentication: ${help_1.HELP.plugin.configuration.authentication.jira.root}

                For more information, set the plugin to debug mode: ${help_1.HELP.plugin.configuration.plugin.debug}
            `));
    }
}
