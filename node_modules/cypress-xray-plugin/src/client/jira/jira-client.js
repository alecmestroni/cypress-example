"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseJiraClient = void 0;
const form_data_1 = __importDefault(require("form-data"));
const fs_1 = __importDefault(require("fs"));
const dedent_1 = require("../../util/dedent");
const errors_1 = require("../../util/errors");
const logging_1 = require("../../util/logging");
const client_1 = require("../client");
/**
 * A Jira client class for communicating with Jira instances.
 */
class BaseJiraClient extends client_1.Client {
    async addAttachment(issueIdOrKey, ...files) {
        if (files.length === 0) {
            logging_1.LOG.message(logging_1.Level.WARNING, `No files provided to attach to issue ${issueIdOrKey}. Skipping attaching.`);
            return [];
        }
        const form = new form_data_1.default();
        let filesIncluded = 0;
        files.forEach((file) => {
            if (!fs_1.default.existsSync(file)) {
                logging_1.LOG.message(logging_1.Level.WARNING, "File does not exist:", file);
                return;
            }
            filesIncluded++;
            const fileContent = fs_1.default.createReadStream(file);
            form.append("file", fileContent);
        });
        if (filesIncluded === 0) {
            logging_1.LOG.message(logging_1.Level.WARNING, "All files do not exist. Skipping attaching.");
            return [];
        }
        try {
            const header = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Attaching files:", ...files);
            const response = await this.httpClient.post(`${this.apiBaseUrl}/rest/api/latest/issue/${issueIdOrKey}/attachments`, form, {
                headers: {
                    ...header,
                    ...form.getHeaders(),
                    ["X-Atlassian-Token"]: "no-check",
                },
            });
            logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                    Successfully attached the following files to issue ${issueIdOrKey}:

                      ${response.data.map((attachment) => attachment.filename).join("\n")}
                `));
            return response.data;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to attach files: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "addAttachmentError");
            throw new errors_1.LoggedError("Failed to add attachments to issue");
        }
    }
    async getIssueTypes() {
        const authorizationHeader = await this.credentials.getAuthorizationHeader();
        logging_1.LOG.message(logging_1.Level.DEBUG, "Getting issue types...");
        try {
            const response = await this.httpClient.get(`${this.apiBaseUrl}/rest/api/latest/issuetype`, {
                headers: {
                    ...authorizationHeader,
                },
            });
            logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully retrieved data for ${response.data.length.toString()} issue types.`);
            logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                    Received data for issue types:

                      ${response.data
                .map((issueType) => {
                if (issueType.name) {
                    if (issueType.id) {
                        return `${issueType.name} (id: ${issueType.id})`;
                    }
                    return `${issueType.name} (id: undefined)`;
                }
                else if (issueType.id) {
                    return `undefined (id: ${issueType.id})`;
                }
                return "undefined (id: undefined)";
            })
                .join("\n")}
                    `));
            return response.data;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to get issue types: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "getIssueTypesError");
            throw new errors_1.LoggedError("Failed to fetch Jira issue types");
        }
    }
    async getFields() {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Getting fields...");
            const response = await this.httpClient.get(`${this.apiBaseUrl}/rest/api/latest/field`, {
                headers: {
                    ...authorizationHeader,
                },
            });
            logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully retrieved data for ${response.data.length.toString()} fields.`);
            logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                    Received data for fields:

                      ${response.data.map((field) => `${field.name} (id: ${field.id})`).join("\n")}
                `));
            return response.data;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to get fields: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "getFieldsError");
            throw new errors_1.LoggedError("Failed to fetch Jira fields");
        }
    }
    async getMyself() {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Getting user details...");
            const response = await this.httpClient.get(`${this.apiBaseUrl}/rest/api/latest/myself`, {
                headers: {
                    ...authorizationHeader,
                },
            });
            logging_1.LOG.message(logging_1.Level.DEBUG, "Successfully retrieved user details.");
            return response.data;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to get user details: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "getMyselfError");
            throw new errors_1.LoggedError("Failed to fetch user details");
        }
    }
    async search(request) {
        try {
            const header = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Searching issues...");
            let total = 0;
            let startAt = request.startAt ?? 0;
            const results = {};
            do {
                const paginatedRequest = {
                    ...request,
                    startAt: startAt,
                };
                const response = await this.httpClient.post(`${this.apiBaseUrl}/rest/api/latest/search`, paginatedRequest, {
                    headers: {
                        ...header,
                    },
                });
                total = response.data.total ?? total;
                if (response.data.issues) {
                    for (const issue of response.data.issues) {
                        if (issue.key) {
                            results[issue.key] = issue;
                        }
                    }
                    // Explicit check because it could also be 0.
                    if (typeof response.data.startAt === "number") {
                        startAt = response.data.startAt + response.data.issues.length;
                    }
                }
            } while (startAt && startAt < total);
            logging_1.LOG.message(logging_1.Level.DEBUG, `Found ${total.toString()} issues`);
            return Object.values(results);
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to search issues: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "searchError");
            throw new errors_1.LoggedError("Failed to search for issues");
        }
    }
    async editIssue(issueIdOrKey, issueUpdateData) {
        try {
            const header = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Editing issue...");
            await this.httpClient.put(`${this.apiBaseUrl}/rest/api/latest/issue/${issueIdOrKey}`, issueUpdateData, {
                headers: {
                    ...header,
                },
            });
            logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully edited issue: ${issueIdOrKey}`);
            return issueIdOrKey;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to edit issue: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "editIssue");
            throw new errors_1.LoggedError("Failed to edit issue");
        }
    }
}
exports.BaseJiraClient = BaseJiraClient;
