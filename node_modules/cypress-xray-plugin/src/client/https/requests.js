"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxiosRestClient = void 0;
const axios_1 = __importStar(require("axios"));
const form_data_1 = __importDefault(require("form-data"));
const files_1 = require("../../util/files");
const logging_1 = require("../../util/logging");
const string_1 = require("../../util/string");
const time_1 = require("../../util/time");
class AxiosRestClient {
    options;
    createdLogFiles;
    axios;
    lastRequestTime;
    constructor(options) {
        this.options = options;
        this.createdLogFiles = new Map();
        this.axios = undefined;
        this.lastRequestTime = undefined;
    }
    async get(url, config) {
        await this.delayIfNeeded();
        const progressInterval = this.startResponseInterval(url);
        try {
            return await this.getAxios().get(url, {
                ...this.options?.http,
                ...config,
            });
        }
        finally {
            clearInterval(progressInterval);
        }
    }
    async post(url, data, config) {
        await this.delayIfNeeded();
        const progressInterval = this.startResponseInterval(url);
        try {
            return await this.getAxios().post(url, data, {
                ...this.options?.http,
                ...config,
            });
        }
        finally {
            clearInterval(progressInterval);
        }
    }
    async put(url, data, config) {
        await this.delayIfNeeded();
        const progressInterval = this.startResponseInterval(url);
        try {
            return await this.getAxios().put(url, data, {
                ...this.options?.http,
                ...config,
            });
        }
        finally {
            clearInterval(progressInterval);
        }
    }
    getAxios() {
        if (!this.axios) {
            this.axios = axios_1.default.create();
            if (this.options?.debug) {
                this.axios.interceptors.request.use((request) => {
                    this.logRequest(request);
                    return request;
                });
                this.axios.interceptors.response.use((response) => {
                    this.logResponse(response);
                    return response;
                });
            }
            this.axios.interceptors.request.use((request) => request, (error) => {
                this.logError("outbound", error);
                return Promise.reject(error instanceof Error ? error : new Error((0, string_1.unknownToString)(error)));
            });
            this.axios.interceptors.response.use((response) => response, (error) => {
                this.logError("inbound", error);
                return Promise.reject(error instanceof Error ? error : new Error((0, string_1.unknownToString)(error)));
            });
        }
        return this.axios;
    }
    logRequest(request) {
        const method = request.method?.toUpperCase();
        const url = request.url;
        let prefix = dateToTimestamp(new Date());
        if (method) {
            prefix = `${prefix}_${method}`;
        }
        if (url) {
            prefix = `${prefix}_${url}`;
        }
        const filename = `${this.appendSuffix((0, files_1.normalizedFilename)(`${prefix}_request`))}.json`;
        if (request.data instanceof form_data_1.default) {
            const formData = request.data;
            const chunks = [];
            let bytesRead = 0;
            const listener = (chunk) => {
                bytesRead += chunk.length;
                if (bytesRead > Math.floor(1024 * 1024 * (this.options?.fileSizeLimit ?? 50))) {
                    chunks.push("[... omitted due to file size]");
                    formData.off("data", listener);
                    return;
                }
                chunks.push(chunk);
            };
            formData.on("data", listener);
            formData.on("end", () => {
                const resolvedFilename = logging_1.LOG.logToFile(JSON.stringify({
                    body: chunks.map((chunk) => chunk.toString("utf-8")).join(""),
                    headers: request.headers,
                    params: request.params,
                    url: url,
                }, null, 2), filename);
                logging_1.LOG.message(logging_1.Level.DEBUG, `Request:  ${resolvedFilename}`);
            });
        }
        else {
            const resolvedFilename = logging_1.LOG.logToFile(JSON.stringify({
                body: request.data,
                headers: request.headers,
                params: request.params,
                url: url,
            }, null, 2), filename);
            logging_1.LOG.message(logging_1.Level.DEBUG, `Request:  ${resolvedFilename}`);
        }
    }
    logResponse(response) {
        const request = response.request;
        const method = request.method?.toUpperCase();
        const url = response.config.url;
        let prefix = dateToTimestamp(new Date());
        if (method) {
            prefix = `${prefix}_${method}`;
        }
        if (url) {
            prefix = `${prefix}_${url}`;
        }
        const filename = `${this.appendSuffix((0, files_1.normalizedFilename)(`${prefix}_response`))}.json`;
        const resolvedFilename = logging_1.LOG.logToFile(JSON.stringify({
            data: response.data,
            headers: response.headers,
            status: response.status,
            statusText: response.statusText,
        }, null, 2), filename);
        logging_1.LOG.message(logging_1.Level.DEBUG, `Response: ${resolvedFilename}`);
    }
    logError(direction, error) {
        let data;
        let prefix = dateToTimestamp(new Date());
        if ((0, axios_1.isAxiosError)(error)) {
            const method = error.config?.method?.toUpperCase();
            const url = error.config?.url;
            if (method) {
                prefix = `${prefix}_${method}`;
            }
            if (url) {
                prefix = `${prefix}_${url}`;
            }
            data = error.toJSON();
        }
        else {
            data = error;
        }
        const filename = `${this.appendSuffix((0, files_1.normalizedFilename)(`${prefix}_${direction === "inbound" ? "response" : "request"}`))}.json`;
        const resolvedFilename = logging_1.LOG.logToFile(JSON.stringify(data, null, 2), filename);
        logging_1.LOG.message(logging_1.Level.DEBUG, `${direction === "inbound" ? "Response" : "Request"}: ${resolvedFilename}`);
    }
    startResponseInterval(url) {
        return (0, time_1.startInterval)((totalTime) => {
            logging_1.LOG.message(logging_1.Level.INFO, `Waiting for ${url} to respond... (${(totalTime / 1000).toString()} seconds)`);
        });
    }
    appendSuffix(filename) {
        const filenameCount = this.createdLogFiles.get(filename);
        if (filenameCount) {
            this.createdLogFiles.set(filename, filenameCount + 1);
            return `${filename}_${filenameCount.toString()}`;
        }
        else {
            this.createdLogFiles.set(filename, 1);
            return filename;
        }
    }
    async delayIfNeeded() {
        // We specifically do not use axios interceptors here because we would need to handle
        // connection timeouts, ECONNRESET etc. otherwise (I think).
        if (this.options?.rateLimiting?.requestsPerSecond) {
            const interval = 1000 / this.options.rateLimiting.requestsPerSecond;
            const now = Date.now();
            const nextRequestTime = this.lastRequestTime ? this.lastRequestTime + interval : now;
            this.lastRequestTime = nextRequestTime;
            const delay = nextRequestTime - now;
            if (delay > 0) {
                await new Promise((resolve) => {
                    setTimeout(resolve, delay);
                });
            }
        }
    }
}
exports.AxiosRestClient = AxiosRestClient;
function dateToTimestamp(date) {
    return `${date.getHours().toString().padStart(2, "0")}_${date
        .getMinutes()
        .toString()
        .padStart(2, "0")}_${date.getSeconds().toString().padStart(2, "0")}`;
}
