"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrayClientCloud = void 0;
const form_data_1 = __importDefault(require("form-data"));
const dedent_1 = require("../../util/dedent");
const errors_1 = require("../../util/errors");
const logging_1 = require("../../util/logging");
const xray_client_1 = require("./xray-client");
class XrayClientCloud extends xray_client_1.AbstractXrayClient {
    /**
     * The URLs of Xray's Cloud API.
     * Note: API v1 would also work, but let's stick to the more recent one.
     */
    static URL = "https://xray.cloud.getxray.app/api/v2";
    static URL_GRAPHQL = `${XrayClientCloud.URL}/graphql`;
    static GRAPHQL_LIMIT = 100;
    /**
     * Construct a new Xray cloud client using the provided credentials.
     *
     * @param credentials - the credentials to use during authentication
     * @param httpClient - the HTTP client to use for dispatching requests
     */
    constructor(credentials, httpClient) {
        super(XrayClientCloud.URL, credentials, httpClient);
    }
    async getTestResults(issueId) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Retrieving test results...");
            const tests = [];
            let total = 0;
            let start = 0;
            const query = (0, dedent_1.dedent)(`
                query($issueId: String, $start: Int!, $limit: Int!) {
                    getTestExecution(issueId: $issueId) {
                        tests(start: $start, limit: $limit) {
                            total
                            start
                            limit
                            results {
                                issueId
                                status {
                                    name
                                }
                                jira(fields: ["key", "summary"])
                            }
                        }
                    }
                }
            `);
            do {
                const paginatedRequest = {
                    query: query,
                    variables: {
                        issueId: issueId,
                        limit: XrayClientCloud.GRAPHQL_LIMIT,
                        start: start,
                    },
                };
                const response = await this.httpClient.post(XrayClientCloud.URL_GRAPHQL, paginatedRequest, {
                    headers: {
                        ...authorizationHeader,
                    },
                });
                const data = response.data.data.getTestExecution;
                total = data.tests?.total ?? total;
                if (data.tests?.results) {
                    if (typeof data.tests.start === "number") {
                        start = data.tests.start + data.tests.results.length;
                    }
                    for (const test of data.tests.results) {
                        if (test.status?.name) {
                            tests.push(test);
                        }
                    }
                }
            } while (start && start < total);
            logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully retrieved test results for test execution issue: ${issueId}`);
            return tests;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to get test results: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "getTestResultsError");
            throw new errors_1.LoggedError("Failed to get test results");
        }
    }
    /**
     * Returns Xray test types for the provided test issues, such as `Manual`, `Cucumber` or
     * `Generic`.
     *
     * @param projectKey - key of the project containing the test issues
     * @param issueKeys - the keys of the test issues to retrieve test types for
     * @returns a promise which will contain the mapping of issues to test types
     */
    async getTestTypes(projectKey, ...issueKeys) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Retrieving test types...");
            const types = {};
            let total = 0;
            let start = 0;
            const query = (0, dedent_1.dedent)(`
                query($jql: String, $start: Int!, $limit: Int!) {
                    getTests(jql: $jql, start: $start, limit: $limit) {
                        total
                        start
                        results {
                            testType {
                                name
                                kind
                            }
                            jira(fields: ["key"])
                        }
                    }
                }
            `);
            do {
                const paginatedRequest = {
                    query: query,
                    variables: {
                        jql: `project = '${projectKey}' AND issue in (${issueKeys.join(",")})`,
                        limit: XrayClientCloud.GRAPHQL_LIMIT,
                        start: start,
                    },
                };
                const response = await this.httpClient.post(XrayClientCloud.URL_GRAPHQL, paginatedRequest, {
                    headers: {
                        ...authorizationHeader,
                    },
                });
                total = response.data.data.getTests.total ?? total;
                if (response.data.data.getTests.results) {
                    if (typeof response.data.data.getTests.start === "number") {
                        start =
                            response.data.data.getTests.start +
                                response.data.data.getTests.results.length;
                    }
                    for (const test of response.data.data.getTests.results) {
                        if (test.jira.key && test.testType?.name) {
                            types[test.jira.key] = test.testType.name;
                        }
                    }
                }
            } while (start && start < total);
            logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully retrieved test types for ${issueKeys.length.toString()} issues.`);
            return types;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to get test types: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "getTestTypes");
            throw new errors_1.LoggedError("Failed to get test types");
        }
    }
    onRequest(event, ...args) {
        switch (event) {
            case "import-execution-cucumber-multipart": {
                // Cast valid because of overload.
                const [cucumberJson, cucumberInfo] = args;
                const resultString = JSON.stringify(cucumberJson);
                const infoString = JSON.stringify(cucumberInfo);
                const formData = new form_data_1.default();
                formData.append("results", resultString, {
                    filename: "results.json",
                });
                formData.append("info", infoString, {
                    filename: "info.json",
                });
                return formData;
            }
            case "import-execution-multipart": {
                // Cast valid because of overload.
                const [executionResults, info] = args;
                const resultString = JSON.stringify(executionResults);
                const infoString = JSON.stringify(info);
                const formData = new form_data_1.default();
                formData.append("results", resultString, {
                    filename: "results.json",
                });
                formData.append("info", infoString, {
                    filename: "info.json",
                });
                return formData;
            }
        }
    }
    onResponse(event, ...args) {
        switch (event) {
            case "import-feature": {
                // Cast valid because of overload.
                const [cloudResponse] = args;
                const response = {
                    errors: [],
                    updatedOrCreatedIssues: [],
                };
                if (cloudResponse.errors.length > 0) {
                    response.errors.push(...cloudResponse.errors);
                    logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                            Encountered some errors during feature file import:
                            ${cloudResponse.errors.map((error) => `- ${error}`).join("\n")}
                        `));
                }
                if (cloudResponse.updatedOrCreatedTests.length > 0) {
                    const testKeys = cloudResponse.updatedOrCreatedTests.map((test) => test.key);
                    response.updatedOrCreatedIssues.push(...testKeys);
                    logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                            Successfully updated or created test issues:

                              ${testKeys.join("\n")}
                        `));
                }
                if (cloudResponse.updatedOrCreatedPreconditions.length > 0) {
                    const preconditionKeys = cloudResponse.updatedOrCreatedPreconditions.map((test) => test.key);
                    response.updatedOrCreatedIssues.push(...preconditionKeys);
                    logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                            Successfully updated or created precondition issues:

                              ${preconditionKeys.join(", ")}
                        `));
                }
                return response;
            }
            case "import-execution-cucumber-multipart":
            case "import-execution-multipart":
            case "import-execution": {
                // Cast valid because of overload.
                const [cloudResponse] = args;
                return cloudResponse.key;
            }
        }
    }
}
exports.XrayClientCloud = XrayClientCloud;
