"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractXrayClient = void 0;
const axios_1 = require("axios");
const form_data_1 = __importDefault(require("form-data"));
const node_fs_1 = __importDefault(require("node:fs"));
const dedent_1 = require("../../util/dedent");
const errors_1 = require("../../util/errors");
const help_1 = require("../../util/help");
const logging_1 = require("../../util/logging");
const client_1 = require("../client");
/**
 * An abstract Xray client class for communicating with Xray instances.
 */
class AbstractXrayClient extends client_1.Client {
    async importExecution(execution) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.INFO, "Importing Cypress execution...");
            const response = await this.httpClient.post(this.getUrlImportExecution(), execution, {
                headers: {
                    ...authorizationHeader,
                },
            });
            const key = this.onResponse("import-execution", response.data);
            logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully uploaded test execution results to ${key}.`);
            return key;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to import execution: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "importExecutionError");
            throw new errors_1.LoggedError("Failed to import Cypress execution results");
        }
    }
    async importFeature(file, query) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Importing Cucumber features...");
            const formData = new form_data_1.default();
            formData.append("file", node_fs_1.default.createReadStream(file));
            const response = await this.httpClient.post(this.getUrlImportFeature(query.projectKey, query.projectId, query.source), formData, {
                headers: {
                    ...authorizationHeader,
                    ...formData.getHeaders(),
                },
            });
            return this.onResponse("import-feature", response.data);
        }
        catch (error) {
            logging_1.LOG.logErrorToFile(error, "importFeatureError");
            if ((0, axios_1.isAxiosError)(error) && error.response?.status === axios_1.HttpStatusCode.BadRequest) {
                logging_1.LOG.message(logging_1.Level.ERROR, (0, dedent_1.dedent)(`
                        Failed to import Cucumber features: ${(0, errors_1.errorMessage)(error)}

                          The prefixes in Cucumber background or scenario tags might not be consistent with the scheme defined in Xray.

                          For more information, visit:
                          - ${help_1.HELP.plugin.configuration.cucumber.prefixes}
                    `));
            }
            else {
                logging_1.LOG.message(logging_1.Level.ERROR, `Failed to import Cucumber features: ${(0, errors_1.errorMessage)(error)}`);
            }
            throw new errors_1.LoggedError("Feature file import failed");
        }
    }
    async importExecutionCucumberMultipart(cucumberJson, cucumberInfo) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.INFO, "Importing Cucumber execution...");
            const formData = this.onRequest("import-execution-cucumber-multipart", cucumberJson, cucumberInfo);
            const response = await this.httpClient.post(this.getUrlImportExecutionCucumberMultipart(), formData, {
                headers: {
                    ...authorizationHeader,
                    ...formData.getHeaders(),
                },
            });
            const key = this.onResponse("import-execution-cucumber-multipart", response.data);
            logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully uploaded Cucumber test execution results to ${key}.`);
            return key;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to import Cucumber execution: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "importExecutionCucumberMultipartError");
            throw new errors_1.LoggedError("Failed to import Cucumber execution results");
        }
    }
    async importExecutionMultipart(executionResults, info) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.INFO, "Importing Cypress execution...");
            const formData = this.onRequest("import-execution-multipart", executionResults, info);
            const response = await this.httpClient.post(this.getUrlImportExecutionMultipart(), formData, {
                headers: {
                    ...authorizationHeader,
                    ...formData.getHeaders(),
                },
            });
            const key = this.onResponse("import-execution-multipart", response.data);
            logging_1.LOG.message(logging_1.Level.DEBUG, `Successfully uploaded test execution results to ${key}.`);
            return key;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to import execution: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "importExecutionMultipartError");
            throw new errors_1.LoggedError("Failed to import Cypress execution results");
        }
    }
    getUrlImportFeature(projectKey, projectId, source) {
        const query = [];
        if (projectKey) {
            query.push(`projectKey=${projectKey}`);
        }
        if (projectId) {
            query.push(`projectId=${projectId}`);
        }
        if (source) {
            query.push(`source=${source}`);
        }
        return `${this.apiBaseUrl}/import/feature?${query.join("&")}`;
    }
    getUrlImportExecution() {
        return `${this.apiBaseUrl}/import/execution`;
    }
    getUrlImportExecutionCucumberMultipart() {
        return `${this.apiBaseUrl}/import/execution/cucumber/multipart`;
    }
    getUrlImportExecutionMultipart() {
        return `${this.apiBaseUrl}/import/execution/multipart`;
    }
}
exports.AbstractXrayClient = AbstractXrayClient;
