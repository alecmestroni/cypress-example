"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerClient = void 0;
const form_data_1 = __importDefault(require("form-data"));
const dedent_1 = require("../../util/dedent");
const errors_1 = require("../../util/errors");
const logging_1 = require("../../util/logging");
const xray_client_1 = require("./xray-client");
class ServerClient extends xray_client_1.AbstractXrayClient {
    /**
     * Construct a new client using the provided credentials.
     *
     * @param apiBaseUrl - the base URL for all HTTP requests
     * @param credentials - the credentials to use during authentication
     * @param httpClient - the HTTP client to use for dispatching requests
     */
    constructor(apiBaseUrl, credentials, httpClient) {
        super(`${apiBaseUrl}/rest/raven/latest`, credentials, httpClient);
    }
    async getTestExecution(testExecutionIssueKey, query) {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Getting test execution results...");
            let currentPage = query?.page ?? 1;
            let pagedTests = [];
            const allTests = [];
            do {
                const testsResponse = await this.httpClient.get(`${this.apiBaseUrl}/api/testexec/${testExecutionIssueKey}/test`, {
                    headers: {
                        ...authorizationHeader,
                    },
                    params: {
                        detailed: query?.detailed,
                        limit: query?.limit,
                        page: currentPage,
                    },
                });
                allTests.push(...testsResponse.data);
                pagedTests = testsResponse.data;
                currentPage++;
            } while (pagedTests.length > 0);
            return allTests;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to retrieve test execution information: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "getTestExecutionError");
            throw new errors_1.LoggedError("Failed to get test execution information");
        }
    }
    async getXrayLicense() {
        try {
            const authorizationHeader = await this.credentials.getAuthorizationHeader();
            logging_1.LOG.message(logging_1.Level.DEBUG, "Getting Xray license status...");
            const licenseResponse = await this.httpClient.get(`${this.apiBaseUrl}/api/xraylicense`, {
                headers: {
                    ...authorizationHeader,
                },
            });
            return licenseResponse.data;
        }
        catch (error) {
            logging_1.LOG.message(logging_1.Level.ERROR, `Failed to retrieve license information: ${(0, errors_1.errorMessage)(error)}`);
            logging_1.LOG.logErrorToFile(error, "getXrayLicenseError");
            throw new errors_1.LoggedError("Failed to get Xray license");
        }
    }
    onRequest(event, ...args) {
        switch (event) {
            case "import-execution-cucumber-multipart": {
                // Cast valid because of overload.
                const [cucumberJson, cucumberInfo] = args;
                const resultString = JSON.stringify(cucumberJson);
                const infoString = JSON.stringify(cucumberInfo);
                const formData = new form_data_1.default();
                formData.append("result", resultString, {
                    filename: "results.json",
                });
                formData.append("info", infoString, {
                    filename: "info.json",
                });
                return formData;
            }
            case "import-execution-multipart": {
                // Cast valid because of overload.
                const [executionResults, info] = args;
                const resultString = JSON.stringify(executionResults);
                const infoString = JSON.stringify(info);
                const formData = new form_data_1.default();
                formData.append("result", resultString, {
                    filename: "results.json",
                });
                formData.append("info", infoString, {
                    filename: "info.json",
                });
                return formData;
            }
        }
    }
    onResponse(event, ...args) {
        switch (event) {
            case "import-feature": {
                // Cast valid because of overload.
                const [serverResponse] = args;
                const response = {
                    errors: [],
                    updatedOrCreatedIssues: [],
                };
                if (Array.isArray(serverResponse)) {
                    const issueKeys = serverResponse.map((test) => test.key);
                    response.updatedOrCreatedIssues.push(...issueKeys);
                    logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                            Successfully updated or created issues:

                              ${issueKeys.join(", ")}
                        `));
                    return response;
                }
                // Occurs when scenarios cause errors in Xray, e.g. typos in keywords ('Scenariot').
                if (serverResponse.message) {
                    response.errors.push(serverResponse.message);
                    logging_1.LOG.message(logging_1.Level.DEBUG, `Encountered an error during feature file import: ${serverResponse.message}`);
                }
                if (serverResponse.testIssues && serverResponse.testIssues.length > 0) {
                    const testKeys = serverResponse.testIssues.map((test) => test.key);
                    response.updatedOrCreatedIssues.push(...testKeys);
                    logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                            Successfully updated or created test issues:

                              ${testKeys.join(", ")}
                        `));
                }
                if (serverResponse.preconditionIssues &&
                    serverResponse.preconditionIssues.length > 0) {
                    const preconditionKeys = serverResponse.preconditionIssues.map((test) => test.key);
                    response.updatedOrCreatedIssues.push(...preconditionKeys);
                    logging_1.LOG.message(logging_1.Level.DEBUG, (0, dedent_1.dedent)(`
                            Successfully updated or created precondition issues:

                              ${preconditionKeys.join(", ")}
                        `));
                }
                return response;
            }
            case "import-execution-cucumber-multipart":
            case "import-execution-multipart":
            case "import-execution": {
                // Cast valid because of overload.
                const [serverResponse] = args;
                return serverResponse.testExecIssue.key;
            }
        }
    }
}
exports.ServerClient = ServerClient;
