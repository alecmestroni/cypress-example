"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addUploadCommands = addUploadCommands;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const logging_1 = require("../../util/logging");
const command_1 = require("../command");
const destructure_command_1 = require("../util/commands/destructure-command");
const fallback_command_1 = require("../util/commands/fallback-command");
const attach_files_command_1 = require("../util/commands/jira/attach-files-command");
const extract_field_id_command_1 = require("../util/commands/jira/extract-field-id-command");
const fetch_issue_types_command_1 = require("../util/commands/jira/fetch-issue-types-command");
const get_summary_values_command_1 = require("../util/commands/jira/get-summary-values-command");
const import_execution_cucumber_command_1 = require("../util/commands/xray/import-execution-cucumber-command");
const import_execution_cypress_command_1 = require("../util/commands/xray/import-execution-cypress-command");
const import_feature_command_1 = require("../util/commands/xray/import-feature-command");
const util_1 = require("../util/util");
const convert_info_command_1 = require("./commands/conversion/convert-info-command");
const assert_cucumber_conversion_valid_command_1 = require("./commands/conversion/cucumber/assert-cucumber-conversion-valid-command");
const combine_cucumber_multipart_command_1 = require("./commands/conversion/cucumber/combine-cucumber-multipart-command");
const convert_cucumber_features_command_1 = require("./commands/conversion/cucumber/convert-cucumber-features-command");
const assert_cypress_conversion_valid_command_1 = require("./commands/conversion/cypress/assert-cypress-conversion-valid-command");
const combine_cypress_xray_command_1 = require("./commands/conversion/cypress/combine-cypress-xray-command");
const convert_cypress_tests_command_1 = require("./commands/conversion/cypress/convert-cypress-tests-command");
const extract_execution_issue_type_command_1 = require("./commands/extract-execution-issue-type-command");
const extract_video_files_command_1 = require("./commands/extract-video-files-command");
const verify_execution_issue_key_command_1 = require("./commands/verify-execution-issue-key-command");
const verify_results_upload_command_1 = require("./commands/verify-results-upload-command");
const util_2 = require("./util");
function addUploadCommands(runResult, projectRoot, options, clients, evidenceCollection, graph, logger) {
    const containsCypressTests = (0, util_2.containsCypressTest)(runResult, options.cucumber?.featureFileExtension);
    const containsCucumberTests = (0, util_2.containsCucumberTest)(runResult, options.cucumber?.featureFileExtension);
    if (!containsCypressTests && !containsCucumberTests) {
        logger.message(logging_1.Level.WARNING, "No test execution results to upload, skipping results upload preparations.");
        return;
    }
    const cypressResultsCommand = (0, util_1.getOrCreateConstantCommand)(graph, logger, runResult);
    let importCypressExecutionCommand = null;
    let importCucumberExecutionCommand = null;
    if (containsCypressTests) {
        importCypressExecutionCommand = getImportExecutionCypressCommand(cypressResultsCommand, options, clients, evidenceCollection, graph, logger);
    }
    if (containsCucumberTests) {
        if (!options.cucumber?.preprocessor?.json.output) {
            throw new Error("Failed to prepare Cucumber upload: Cucumber preprocessor JSON report path not configured.");
        }
        // Cypress might change process.cwd(), so we need to query the root directory.
        // See: https://github.com/cypress-io/cypress/issues/22689
        const reportPath = path_1.default.resolve(projectRoot, options.cucumber.preprocessor.json.output);
        const cucumberResults = JSON.parse(fs_1.default.readFileSync(reportPath, "utf-8"));
        const cucumberResultsCommand = (0, util_1.getOrCreateConstantCommand)(graph, logger, cucumberResults);
        let testExecutionIssueKeyCommand = undefined;
        if (options.jira.testExecutionIssueKey) {
            testExecutionIssueKeyCommand = (0, util_1.getOrCreateConstantCommand)(graph, logger, options.jira.testExecutionIssueKey);
        }
        else if (importCypressExecutionCommand) {
            // Use an optional command in case the Cypress import fails. We could then still upload
            // Cucumber results.
            const fallbackExecutionIssueKeyCommand = graph.place(new fallback_command_1.FallbackCommand({
                fallbackOn: [command_1.ComputableState.FAILED, command_1.ComputableState.SKIPPED],
                fallbackValue: undefined,
            }, logger, importCypressExecutionCommand));
            graph.connect(importCypressExecutionCommand, fallbackExecutionIssueKeyCommand, true);
            testExecutionIssueKeyCommand = fallbackExecutionIssueKeyCommand;
        }
        importCucumberExecutionCommand = getImportExecutionCucumberCommand(runResult, cucumberResultsCommand, projectRoot, options, clients, graph, logger, testExecutionIssueKeyCommand);
        // Make sure to add an edge from any feature file imports to the execution. Otherwise, the
        // execution will contain old steps (those which were there prior to feature import).
        if (options.cucumber.uploadFeatures) {
            for (const importFeatureCommand of graph.getVertices()) {
                if (importFeatureCommand instanceof import_feature_command_1.ImportFeatureCommand) {
                    if (runResult.runs.some((run) => path_1.default.relative(projectRoot, run.spec.relative) ===
                        importFeatureCommand.getParameters().filePath)) {
                        // We can still upload results even if the feature file import fails. It's
                        // better to upload mismatched results than none at all.
                        graph.connect(importFeatureCommand, importCucumberExecutionCommand, true);
                    }
                }
            }
        }
    }
    addPostUploadCommands(cypressResultsCommand, options, clients, graph, logger, importCypressExecutionCommand, importCucumberExecutionCommand);
}
function getImportExecutionCypressCommand(cypressResultsCommand, options, clients, evidenceCollection, graph, logger) {
    const convertCypressTestsCommand = graph.place(new convert_cypress_tests_command_1.ConvertCypressTestsCommand({
        cucumber: options.cucumber,
        evidenceCollection: evidenceCollection,
        jira: options.jira,
        plugin: options.plugin,
        useCloudStatusFallback: clients.kind === "cloud",
        xray: options.xray,
    }, logger, cypressResultsCommand));
    graph.connect(cypressResultsCommand, convertCypressTestsCommand);
    const convertMultipartInfoCommand = getConvertMultipartInfoCommand(options, clients, graph, logger, cypressResultsCommand);
    const combineResultsJsonCommand = graph.place(new combine_cypress_xray_command_1.CombineCypressJsonCommand({ testExecutionIssueKey: options.jira.testExecutionIssueKey }, logger, convertCypressTestsCommand, convertMultipartInfoCommand));
    graph.connect(convertCypressTestsCommand, combineResultsJsonCommand);
    graph.connect(convertMultipartInfoCommand, combineResultsJsonCommand);
    const assertConversionValidCommand = graph.place(new assert_cypress_conversion_valid_command_1.AssertCypressConversionValidCommand(logger, combineResultsJsonCommand));
    graph.connect(combineResultsJsonCommand, assertConversionValidCommand);
    const importCypressExecutionCommand = graph.place(new import_execution_cypress_command_1.ImportExecutionCypressCommand({ xrayClient: clients.xrayClient }, logger, combineResultsJsonCommand));
    graph.connect(assertConversionValidCommand, importCypressExecutionCommand);
    graph.connect(combineResultsJsonCommand, importCypressExecutionCommand);
    if (options.jira.testExecutionIssueKey) {
        const verifyExecutionIssueKeyCommand = graph.place(new verify_execution_issue_key_command_1.VerifyExecutionIssueKeyCommand({
            displayCloudHelp: clients.kind === "cloud",
            importType: "cypress",
            testExecutionIssueKey: options.jira.testExecutionIssueKey,
            testExecutionIssueType: options.jira.testExecutionIssueType,
        }, logger, importCypressExecutionCommand));
        graph.connect(importCypressExecutionCommand, verifyExecutionIssueKeyCommand);
    }
    return importCypressExecutionCommand;
}
function getImportExecutionCucumberCommand(runResult, cucumberResultsCommand, projectRoot, options, clients, graph, logger, testExecutionIssueKeyCommand) {
    const cypressResultsCommand = (0, util_1.getOrCreateConstantCommand)(graph, logger, runResult);
    const convertMultipartInfoCommand = getConvertMultipartInfoCommand(options, clients, graph, logger, cypressResultsCommand);
    const convertCucumberFeaturesCommand = graph.place(new convert_cucumber_features_command_1.ConvertCucumberFeaturesCommand({
        cucumber: {
            prefixes: {
                precondition: options.cucumber?.prefixes.precondition,
                test: options.cucumber?.prefixes.test,
            },
        },
        jira: {
            projectKey: options.jira.projectKey,
            testExecutionIssueDescription: options.jira.testExecutionIssueDescription,
            testExecutionIssueSummary: options.jira.testExecutionIssueSummary,
            testPlanIssueKey: options.jira.testPlanIssueKey,
        },
        projectRoot: projectRoot,
        useCloudTags: clients.kind === "cloud",
        xray: {
            status: options.xray.status,
            testEnvironments: options.xray.testEnvironments,
            uploadScreenshots: options.xray.uploadScreenshots,
        },
    }, logger, cucumberResultsCommand, testExecutionIssueKeyCommand));
    graph.connect(cucumberResultsCommand, convertCucumberFeaturesCommand);
    if (testExecutionIssueKeyCommand) {
        graph.connect(testExecutionIssueKeyCommand, convertCucumberFeaturesCommand);
    }
    const combineCucumberMultipartCommand = graph.place(new combine_cucumber_multipart_command_1.CombineCucumberMultipartCommand(logger, convertMultipartInfoCommand, convertCucumberFeaturesCommand));
    graph.connect(convertMultipartInfoCommand, combineCucumberMultipartCommand);
    graph.connect(convertCucumberFeaturesCommand, combineCucumberMultipartCommand);
    const assertConversionValidCommand = graph.place(new assert_cucumber_conversion_valid_command_1.AssertCucumberConversionValidCommand(logger, combineCucumberMultipartCommand));
    graph.connect(combineCucumberMultipartCommand, assertConversionValidCommand);
    const importCucumberExecutionCommand = graph.place(new import_execution_cucumber_command_1.ImportExecutionCucumberCommand({ xrayClient: clients.xrayClient }, logger, combineCucumberMultipartCommand));
    graph.connect(assertConversionValidCommand, importCucumberExecutionCommand);
    graph.connect(combineCucumberMultipartCommand, importCucumberExecutionCommand);
    if (options.jira.testExecutionIssueKey) {
        const verifyExecutionIssueKeyCommand = graph.place(new verify_execution_issue_key_command_1.VerifyExecutionIssueKeyCommand({
            displayCloudHelp: clients.kind === "cloud",
            importType: "cucumber",
            testExecutionIssueKey: options.jira.testExecutionIssueKey,
            testExecutionIssueType: options.jira.testExecutionIssueType,
        }, logger, importCucumberExecutionCommand));
        graph.connect(importCucumberExecutionCommand, verifyExecutionIssueKeyCommand);
    }
    return importCucumberExecutionCommand;
}
function getExtractExecutionIssueTypeCommand(options, clients, graph, logger) {
    const fetchIssueTypesCommand = graph.findOrDefault(fetch_issue_types_command_1.FetchIssueTypesCommand, () => graph.place(new fetch_issue_types_command_1.FetchIssueTypesCommand({ jiraClient: clients.jiraClient }, logger)));
    return graph.findOrDefault(extract_execution_issue_type_command_1.ExtractExecutionIssueTypeCommand, () => {
        const extractExecutionIssueTypeCommand = graph.place(new extract_execution_issue_type_command_1.ExtractExecutionIssueTypeCommand({
            displayCloudHelp: clients.kind === "cloud",
            projectKey: options.jira.projectKey,
            testExecutionIssueType: options.jira.testExecutionIssueType,
        }, logger, fetchIssueTypesCommand));
        graph.connect(fetchIssueTypesCommand, extractExecutionIssueTypeCommand);
        return extractExecutionIssueTypeCommand;
    });
}
function getExecutionIssueSummaryCommand(options, clients, graph, logger) {
    if (options.jira.testExecutionIssueSummary) {
        return (0, util_1.getOrCreateConstantCommand)(graph, logger, options.jira.testExecutionIssueSummary);
    }
    if (options.jira.testExecutionIssueKey) {
        const issueKeysCommand = (0, util_1.getOrCreateConstantCommand)(graph, logger, [
            options.jira.testExecutionIssueKey,
        ]);
        const getSummaryValuesCommand = graph.findOrDefault(get_summary_values_command_1.GetSummaryValuesCommand, () => {
            const command = graph.place(new get_summary_values_command_1.GetSummaryValuesCommand({ jiraClient: clients.jiraClient }, logger, issueKeysCommand));
            graph.connect(issueKeysCommand, command);
            return command;
        }, (vertex) => [...graph.getPredecessors(vertex)].includes(issueKeysCommand));
        const destructureCommand = graph.place(new destructure_command_1.DestructureCommand(logger, getSummaryValuesCommand, options.jira.testExecutionIssueKey));
        graph.connect(getSummaryValuesCommand, destructureCommand);
        return destructureCommand;
    }
}
function getConvertMultipartInfoCommand(options, clients, graph, logger, cypressResultsCommand) {
    let convertCommand;
    if (clients.kind === "cloud") {
        convertCommand = graph.find((command) => command instanceof convert_info_command_1.ConvertInfoCloudCommand &&
            [...graph.getPredecessors(command)].includes(cypressResultsCommand));
    }
    else {
        convertCommand = graph.find((command) => command instanceof convert_info_command_1.ConvertInfoServerCommand &&
            [...graph.getPredecessors(command)].includes(cypressResultsCommand));
    }
    if (convertCommand) {
        return convertCommand;
    }
    let textExecutionIssueDataCommand;
    if (options.jira.testExecutionIssue) {
        textExecutionIssueDataCommand = (0, util_1.getOrCreateConstantCommand)(graph, logger, options.jira.testExecutionIssue);
    }
    const executionIssueSummaryCommand = getExecutionIssueSummaryCommand(options, clients, graph, logger);
    const extractExecutionIssueTypeCommand = getExtractExecutionIssueTypeCommand(options, clients, graph, logger);
    if (clients.kind === "cloud") {
        convertCommand = graph.place(new convert_info_command_1.ConvertInfoCloudCommand({ jira: options.jira, xray: options.xray }, logger, extractExecutionIssueTypeCommand, cypressResultsCommand, {
            custom: textExecutionIssueDataCommand,
            summary: executionIssueSummaryCommand,
        }));
    }
    else {
        let testPlanIdCommand = undefined;
        let testEnvironmentsIdCommand = undefined;
        if (options.jira.testPlanIssueKey) {
            testPlanIdCommand = options.jira.fields.testPlan
                ? (0, util_1.getOrCreateConstantCommand)(graph, logger, options.jira.fields.testPlan)
                : (0, util_1.getOrCreateExtractFieldIdCommand)(extract_field_id_command_1.JiraField.TEST_PLAN, clients.jiraClient, graph, logger);
        }
        if (options.xray.testEnvironments) {
            testEnvironmentsIdCommand = options.jira.fields.testEnvironments
                ? (0, util_1.getOrCreateConstantCommand)(graph, logger, options.jira.fields.testEnvironments)
                : (0, util_1.getOrCreateExtractFieldIdCommand)(extract_field_id_command_1.JiraField.TEST_ENVIRONMENTS, clients.jiraClient, graph, logger);
        }
        convertCommand = graph.place(new convert_info_command_1.ConvertInfoServerCommand({ jira: options.jira, xray: options.xray }, logger, extractExecutionIssueTypeCommand, cypressResultsCommand, {
            custom: textExecutionIssueDataCommand,
            fieldIds: {
                testEnvironmentsId: testEnvironmentsIdCommand,
                testPlanId: testPlanIdCommand,
            },
            summary: executionIssueSummaryCommand,
        }));
        if (testPlanIdCommand) {
            graph.connect(testPlanIdCommand, convertCommand);
        }
        if (testEnvironmentsIdCommand) {
            graph.connect(testEnvironmentsIdCommand, convertCommand);
        }
    }
    if (textExecutionIssueDataCommand) {
        graph.connect(textExecutionIssueDataCommand, convertCommand);
    }
    graph.connect(extractExecutionIssueTypeCommand, convertCommand);
    graph.connect(cypressResultsCommand, convertCommand);
    if (executionIssueSummaryCommand) {
        graph.connect(executionIssueSummaryCommand, convertCommand);
    }
    return convertCommand;
}
function addPostUploadCommands(cypressResultsCommand, options, clients, graph, logger, importCypressExecutionCommand, importCucumberExecutionCommand) {
    let fallbackCypressUploadCommand = undefined;
    let fallbackCucumberUploadCommand = undefined;
    if (importCypressExecutionCommand) {
        fallbackCypressUploadCommand = graph.findOrDefault((fallback_command_1.FallbackCommand), () => {
            const fallbackCommand = graph.place(new fallback_command_1.FallbackCommand({
                fallbackOn: [command_1.ComputableState.FAILED, command_1.ComputableState.SKIPPED],
                fallbackValue: undefined,
            }, logger, importCypressExecutionCommand));
            graph.connect(importCypressExecutionCommand, fallbackCommand, true);
            return fallbackCommand;
        }, (command) => {
            const predecessors = [...graph.getPredecessors(command)];
            return (predecessors.length === 1 && predecessors[0] === importCypressExecutionCommand);
        });
    }
    if (importCucumberExecutionCommand) {
        fallbackCucumberUploadCommand = graph.findOrDefault((fallback_command_1.FallbackCommand), () => {
            const fallbackCommand = graph.place(new fallback_command_1.FallbackCommand({
                fallbackOn: [command_1.ComputableState.FAILED, command_1.ComputableState.SKIPPED],
                fallbackValue: undefined,
            }, logger, importCucumberExecutionCommand));
            graph.connect(importCucumberExecutionCommand, fallbackCommand, true);
            return fallbackCommand;
        }, (command) => {
            const predecessors = [...graph.getPredecessors(command)];
            return (predecessors.length === 1 && predecessors[0] === importCucumberExecutionCommand);
        });
    }
    const verifyResultsUploadCommand = graph.place(new verify_results_upload_command_1.VerifyResultsUploadCommand({ url: options.jira.url }, logger, {
        cucumberExecutionIssueKey: fallbackCucumberUploadCommand,
        cypressExecutionIssueKey: fallbackCypressUploadCommand,
    }));
    if (fallbackCypressUploadCommand) {
        graph.connect(fallbackCypressUploadCommand, verifyResultsUploadCommand);
    }
    if (fallbackCucumberUploadCommand) {
        graph.connect(fallbackCucumberUploadCommand, verifyResultsUploadCommand);
    }
    if (options.jira.attachVideos) {
        const extractVideoFilesCommand = graph.place(new extract_video_files_command_1.ExtractVideoFilesCommand(logger, cypressResultsCommand));
        graph.connect(cypressResultsCommand, extractVideoFilesCommand);
        const attachVideosCommand = graph.place(new attach_files_command_1.AttachFilesCommand({ jiraClient: clients.jiraClient }, logger, extractVideoFilesCommand, verifyResultsUploadCommand));
        graph.connect(extractVideoFilesCommand, attachVideosCommand);
        graph.connect(verifyResultsUploadCommand, attachVideosCommand);
    }
}
