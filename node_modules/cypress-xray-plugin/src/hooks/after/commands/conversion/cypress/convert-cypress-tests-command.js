"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConvertCypressTestsCommand = void 0;
const node_path_1 = __importDefault(require("node:path"));
const semver_1 = require("semver");
const base64_1 = require("../../../../../util/base64");
const dedent_1 = require("../../../../../util/dedent");
const errors_1 = require("../../../../../util/errors");
const files_1 = require("../../../../../util/files");
const logging_1 = require("../../../../../util/logging");
const time_1 = require("../../../../../util/time");
const command_1 = require("../../../../command");
const util_1 = require("../../../util");
const run_1 = require("./util/run");
const status_1 = require("./util/status");
class ConvertCypressTestsCommand extends command_1.Command {
    results;
    constructor(parameters, logger, results) {
        super(parameters, logger);
        this.results = results;
    }
    async computeResult() {
        const results = await this.results.compute();
        const version = (0, semver_1.lt)(results.cypressVersion, "13.0.0") ? "<13" : ">=13";
        const testRunData = await this.getTestRunData(results, version);
        const xrayTests = [];
        testRunData.forEach((testData) => {
            try {
                const issueKeys = (0, util_1.getTestIssueKeys)(testData.title, this.parameters.jira.projectKey);
                for (const issueKey of issueKeys) {
                    const test = this.getTest(testData, issueKey, this.getXrayEvidence(issueKey, testData, version));
                    xrayTests.push(test);
                }
            }
            catch (error) {
                this.logger.message(logging_1.Level.WARNING, (0, dedent_1.dedent)(`
                        ${testData.spec.filepath}

                          Test: ${testData.title}

                            Skipping result upload.

                              Caused by: ${(0, errors_1.errorMessage)(error)}
                    `));
            }
        });
        if (xrayTests.length === 0) {
            throw new Error("Failed to convert Cypress tests into Xray tests: No Cypress tests to upload");
        }
        return [xrayTests[0], ...xrayTests.slice(1)];
    }
    async getTestRunData(runResults, version) {
        const testRunData = [];
        const conversionPromises = [];
        const cypressRuns = runResults.runs.filter((run) => {
            return (!this.parameters.cucumber ||
                !run.spec.relative.endsWith(this.parameters.cucumber.featureFileExtension));
        });
        if (cypressRuns.length === 0) {
            throw new Error("Failed to extract test run data: Only Cucumber tests were executed");
        }
        if (version === "<13") {
            for (const run of cypressRuns) {
                (0, run_1.getTestRunData_V12)(run).forEach((promise, index) => conversionPromises.push([run.tests[index].title.join(" "), promise]));
            }
        }
        else {
            for (const run of cypressRuns) {
                (0, run_1.getTestRunData_V13)(run, this.parameters.jira.projectKey).forEach((promise, index) => conversionPromises.push([run.tests[index].title.join(" "), promise]));
            }
        }
        const convertedTests = await Promise.allSettled(conversionPromises.map((tuple) => tuple[1]));
        convertedTests.forEach((promise, index) => {
            if (promise.status === "fulfilled") {
                testRunData.push(promise.value);
            }
            else {
                this.logger.message(logging_1.Level.WARNING, (0, dedent_1.dedent)(`
                        Test: ${conversionPromises[index][0]}

                          Skipping result upload.

                            Caused by: ${(0, errors_1.errorMessage)(promise.reason)}
                    `));
            }
        });
        if (this.parameters.xray.uploadScreenshots && version === ">=13") {
            for (const run of runResults.runs) {
                if (this.parameters.cucumber?.featureFileExtension &&
                    run.spec.fileExtension.endsWith(this.parameters.cucumber.featureFileExtension)) {
                    continue;
                }
                for (const screenshot of run.screenshots) {
                    if (!this.willBeUploaded(screenshot, testRunData)) {
                        const screenshotName = node_path_1.default.parse(screenshot.path).name;
                        this.logger.message(logging_1.Level.WARNING, (0, dedent_1.dedent)(`
                                ${screenshot.path}

                                  Screenshot cannot be attributed to a test and will not be uploaded.

                                  To upload screenshots, include test issue keys anywhere in their name:

                                    cy.screenshot("${this.parameters.jira.projectKey}-123 ${screenshotName}")
                            `));
                    }
                }
            }
        }
        return testRunData;
    }
    getTest(test, issueKey, evidence) {
        // TODO: Support multiple iterations.
        const xrayTest = {
            finish: (0, time_1.truncateIsoTime)(new Date(test.startedAt.getTime() + test.duration).toISOString()),
            start: (0, time_1.truncateIsoTime)(test.startedAt.toISOString()),
            status: (0, status_1.getXrayStatus)(test.status, this.parameters.useCloudStatusFallback === true, this.parameters.xray.status),
            testKey: issueKey,
        };
        if (evidence.length > 0) {
            xrayTest.evidence = evidence;
        }
        return xrayTest;
    }
    getXrayEvidence(issueKey, testRunData, version) {
        const evidence = [];
        if (this.parameters.xray.uploadScreenshots) {
            for (const screenshot of testRunData.screenshots) {
                let filename = node_path_1.default.basename(screenshot.filepath);
                if (version === ">=13" && !filename.includes(issueKey)) {
                    continue;
                }
                if (this.parameters.plugin.normalizeScreenshotNames) {
                    filename = (0, files_1.normalizedFilename)(filename);
                }
                evidence.push({
                    data: (0, base64_1.encodeFile)(screenshot.filepath),
                    filename: filename,
                });
            }
        }
        this.parameters.evidenceCollection
            .getEvidence(issueKey)
            .forEach((item) => evidence.push(item));
        return evidence;
    }
    willBeUploaded(screenshot, testRunData) {
        return testRunData.some((testRun) => {
            return testRun.screenshots.some(({ filepath }) => {
                return screenshot.path === filepath;
            });
        });
    }
}
exports.ConvertCypressTestsCommand = ConvertCypressTestsCommand;
